<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PDF Compressor - NextGen Tools</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary: #6366f1;
      --secondary: #3b82f6;
      --bg: #ffffff;
      --dark-bg: #0f172a;
      --card: #fff;
      --dark-card: #1e293b;
      --text: #1e293b;
      --text-light: #f8fafc;
      --radius: 12px;
      --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      --glass: rgba(255, 255, 255, 0.05);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Inter', sans-serif;
      background: var(--bg);
      color: var(--text);
      transition: all 0.3s ease;
      padding: 2rem 1rem;
      min-height: 100vh;
    }

    body.dark {
      background: var(--dark-bg);
      color: var(--text-light);
    }

    .container {
      max-width: 800px;
      margin: auto;
      background: var(--card);
      padding: 2.5rem;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      transition: all 0.3s;
      border: 1px solid rgba(0, 0, 0, 0.1);
    }

    body.dark .container {
      background: var(--dark-card);
      border-color: rgba(255, 255, 255, 0.1);
    }

    h1 {
      font-size: 2rem;
      font-weight: 700;
      background: linear-gradient(45deg, var(--primary), var(--secondary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 2rem;
      text-align: center;
    }

    .upload-section {
      position: relative;
      border: 2px dashed #94a3b8;
      border-radius: var(--radius);
      padding: 3rem 2rem;
      text-align: center;
      transition: all 0.3s;
      margin-bottom: 2rem;
    }

    .upload-section:hover {
      border-color: var(--primary);
      background: rgba(99, 102, 241, 0.05);
    }

    .upload-section label {
      background: linear-gradient(45deg, var(--primary), var(--secondary));
      color: white;
      padding: 0.75rem 2rem;
      border-radius: var(--radius);
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      cursor: pointer;
      font-weight: 600;
      transition: transform 0.2s;
      border: none;
    }

    .upload-section input[type=file] {
      display: none;
    }

    .input-group {
      margin: 1.5rem 0;
    }

    .input-group label {
      font-weight: 500;
      display: block;
      margin-bottom: 0.5rem;
    }

    input, select, button {
      width: 100%;
      padding: 0.875rem;
      font-size: 1rem;
      border: 1px solid #e2e8f0;
      border-radius: var(--radius);
      background: var(--bg);
      color: var(--text);
      transition: all 0.3s;
    }

    body.dark input, 
    body.dark select {
      background: #334155;
      border-color: #475569;
    }

    button {
      background: linear-gradient(45deg, var(--primary), var(--secondary));
      color: white;
      font-weight: 600;
      border: none;
      cursor: pointer;
      transition: all 0.3s;
    }

    button:hover {
      opacity: 0.9;
      transform: translateY(-1px);
    }

    #previewContainer {
      margin-top: 2rem;
      background: var(--bg);
      border-radius: var(--radius);
      overflow: hidden;
      border: 1px solid rgba(0, 0, 0, 0.1);
    }

    iframe {
      width: 100%;
      height: 500px;
      border: none;
    }

    .download-link {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      background: linear-gradient(45deg, var(--primary), var(--secondary));
      color: white;
      padding: 0.75rem 1.5rem;
      text-decoration: none;
      border-radius: var(--radius);
      margin-top: 1.5rem;
      font-weight: 500;
      transition: all 0.3s;
    }

    #themeToggle {
      position: fixed;
      top: 1rem;
      right: 1rem;
      padding: 0.5rem;
      border: none;
      border-radius: 50%;
      background: var(--glass);
      backdrop-filter: blur(10px);
      cursor: pointer;
      z-index: 999;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.25rem;
      box-shadow: var(--shadow);
    }
  </style>
</head>
<body>
  <button id="themeToggle" title="Change theme">ðŸŒ“</button>
  <div class="container">
    <h1>PDF Compressor</h1>
    
    <div class="upload-section">
      <label for="pdfFile">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
          <polyline points="17 8 12 3 7 8"></polyline>
          <line x1="12" y1="3" x2="12" y2="15"></line>
        </svg>
        Choose PDF File
      </label>
      <input type="file" id="pdfFile" accept="application/pdf">
    </div>

    <div class="input-group">
      <label>Compression Settings</label>
      <div style="display: grid; grid-template-columns: 1fr 120px; gap: 1rem;">
        <input type="number" id="sizeValue" placeholder="Target size (e.g., 500)" />
        <select id="unit">
          <option value="KB">KB</option>
          <option value="MB">MB</option>
        </select>
      </div>
    </div>

    <button onclick="compressPDF()" style="margin-top: 1rem;">Compress Now</button>

    <div class="status" id="status" style="margin-top: 1.5rem; font-size: 0.9rem; color: #64748b;"></div>

    <div id="previewContainer" style="display:none;">
      <iframe id="pdfPreview"></iframe>
      <a id="downloadLink" class="download-link" href="#" download="compressed.pdf">
        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
          <polyline points="7 10 12 15 17 10"></polyline>
          <line x1="12" y1="15" x2="12" y2="3"></line>
        </svg>
        Download PDF
      </a>
    </div>
  </div>

  <script>
    document.getElementById('themeToggle').addEventListener('click', () => {
      document.body.classList.toggle('dark');
    });

    async function compressPDF() {
      const fileInput = document.getElementById("pdfFile");
      let sizeValue = parseFloat(document.getElementById("sizeValue").value);
      const unit = document.getElementById("unit").value;
      const status = document.getElementById("status");
      const previewContainer = document.getElementById("previewContainer");
      const pdfPreview = document.getElementById("pdfPreview");
      const downloadLink = document.getElementById("downloadLink");

      if (!fileInput.files[0]) {
        status.textContent = "Please upload a PDF file first";
        return;
      }
      if (!sizeValue || sizeValue <= 0) {
        status.textContent = "Enter valid target size";
        return;
      }

      const file = fileInput.files[0];
      const originalSize = file.size;
      const targetSize = unit === 'MB' ? sizeValue * 1024 * 1024 : sizeValue * 1024;
      
      // Calculate minimum possible size (assuming 10% of original size as minimum)
      const minPossibleSize = originalSize * 0.1;
      
      // Adjust target size to be 1 less than user input
      const adjustedSizeValue = sizeValue - 1;
      const adjustedTargetSize = unit === 'MB' ? adjustedSizeValue * 1024 * 1024 : adjustedSizeValue * 1024;

      // Check if compression is possible
      if (adjustedTargetSize < minPossibleSize) {
        status.textContent = `Cannot compress below minimum possible size of ${formatSize(minPossibleSize)}. Please enter a larger target size.`;
        return;
      }

      status.textContent = `Compressing to approximately ${adjustedSizeValue} ${unit}...`;

      // Simulate compression delay
      await new Promise(resolve => setTimeout(resolve, 1000));

      try {
        const compressedBlob = await mockCompression(file, adjustedSizeValue, unit);
        const compressedSize = compressedBlob.size;
        
        // Verify if compressed size is close to target (Â±10% tolerance)
        const sizeDifference = Math.abs(compressedSize - adjustedTargetSize);
        const tolerance = adjustedTargetSize * 0.1;
        
        if (sizeDifference > tolerance) {
          status.textContent = `Compression achieved ${formatSize(compressedSize)}, which is not close enough to target ${adjustedSizeValue} ${unit}`;
          return;
        }

        const url = URL.createObjectURL(compressedBlob);
        
        // Set up preview
        pdfPreview.src = url;
        
        // Set up download link
        downloadLink.href = url;
        downloadLink.setAttribute('download', `compressed_${file.name}`);
        
        previewContainer.style.display = 'block';
        status.textContent = `Compression successful - ${formatSize(compressedSize)} (target: ${adjustedSizeValue} ${unit})`;
      } catch (error) {
        status.textContent = "Compression failed. Please try again.";
        console.error(error);
      }
    }

    function mockCompression(file, size, unit) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          const targetBytes = unit === 'MB' ? size * 1024 * 1024 : size * 1024;
          const buffer = new Uint8Array(reader.result);
          // Simulate compression by returning a blob close to target size
          const compressedBuffer = buffer.slice(0, Math.max(targetBytes, buffer.length * 0.1));
          resolve(new Blob([compressedBuffer], { type: "application/pdf" }));
        };
        reader.onerror = reject;
        reader.readAsArrayBuffer(file);
      });
    }

    function formatSize(bytes) {
      return bytes > 1024 * 1024 
        ? `${(bytes / 1024 / 1024).toFixed(1)} MB`
        : `${(bytes / 1024).toFixed(1)} KB`;
    }
  </script>
</body>
</html>